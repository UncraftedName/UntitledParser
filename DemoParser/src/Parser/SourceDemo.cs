#nullable enable
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using DemoParser.Parser.Components;
using DemoParser.Parser.Components.Abstract;
using DemoParser.Parser.Components.Packets;
using DemoParser.Parser.HelperClasses;
using DemoParser.Parser.HelperClasses.GameState;
using DemoParser.Utils;
using DemoParser.Utils.BitStreams;

namespace DemoParser.Parser {

	/// <summary>
	/// Once parsed, contains an in-memory representation of a demo file.
	/// </summary>
	public class SourceDemo : DemoComponent {

		private BitStreamReader _privateReader;
		public override BitStreamReader Reader => _privateReader.FromBeginning();

		public readonly string? FileName;
		public new DemoInfo DemoInfo;
		public DemoHeader Header;
		public List<PacketFrame> Frames;
		private bool _exceptionDuringParsing;
		// initialized to null, these are set in the packet packet and from console commands
		public int? StartTick, EndTick, StartAdjustmentTick, EndAdjustmentTick;
		internal uint ClientSoundSequence; // increases with each reliable sound

		// Helper classes, these are used by the demo components, are temporary and might be created/destroyed whenever.
		// Any classes that require the use of any lookup tables e.g. string tables, game event list, etc. should store
		// a local copy of any objects from those tables.
		public List<string> ErrorList;
		internal GameEventManager GameEventManager;
		public DataTableParser? DataTableParser;
		internal StringTablesManager StringTablesManager;
		internal EntitySnapshot? EntitySnapshot;
		internal EntityBaseLines? EntBaseLines;
		private readonly IProgress<double>? _parseProgress;

		// We want access to the bit reader of each component after parsing,
		// but some data must be decompressed first so we'll store that data here.
		internal List<byte[]> DecompressedLookup;

		// a way to tell what info did/didn't get parsed
		public DemoParseResult DemoParseResult;


		public SourceDemo(string fileDir, IProgress<double>? parseProgress = null)
			: this(new FileInfo(fileDir), parseProgress) {}


		// the fact that C# only allows ctors to call other ctors with this syntax is quite silly
		public SourceDemo(FileInfo file, IProgress<double>? parseProgress = null) : base(null) {
			if (file.Length > BitStreamReader.MaxDataSize) {
				DemoParseResult |= DemoParseResult.DataTooLong;
			} else {
				_parseProgress = parseProgress;
				FileName = file.Name;
				_privateReader = new BitStreamReader(File.ReadAllBytes(file.FullName));
			}
		}


		public SourceDemo(byte[] data, IProgress<double>? parseProgress = null, string demoName = "")
			: base(null)
		{
			if (data.Length > BitStreamReader.MaxDataSize) {
				DemoParseResult |= DemoParseResult.DataTooLong;
			} else {
				_parseProgress = parseProgress;
				FileName = demoName;
				_privateReader = new BitStreamReader(data);
			}
		}


		protected override void Parse(ref BitStreamReader bsr) {
			if ((DemoParseResult & DemoParseResult.DataTooLong) != 0)
				throw new InvalidDataException("data too long");
			// make sure we set the demo settings first
			Header = new DemoHeader(this);
			Header.ParseStream(ref bsr);
			DemoInfo = new DemoInfo(this);
			// it might be worth it to implement updating helper classes with listeners, but it's not a huge deal atm
			StringTablesManager = new StringTablesManager(this);
			ErrorList = new List<string>();
			DecompressedLookup = new List<byte[]>();
			Frames = new List<PacketFrame>();
			StartTick = 0;
			try {
				PacketFrame frame;
				do {
					frame = new PacketFrame(this);
					Frames.Add(frame);
					frame.ParseStream(ref bsr);
					_parseProgress?.Report((double)bsr.CurrentBitIndex / bsr.BitLength);
				} while (frame.Type != PacketType.Stop && bsr.BitsRemaining >= 24); // would be 32 but the last byte is often cut off
				StartAdjustmentTick ??= 0;
				EndTick = this.FilterForPacket<Packet>().Where(packet => packet.GetType() == typeof(Packet)).Select(packet => packet.Tick).Where(i => i >= 0).Max();
			}
			catch (Exception e) {
				_exceptionDuringParsing = true;
				Debug.WriteLine($"Exception after parsing {Frames.Count - 1} packets");
				LogError($"Exception after parsing {Frames.Count - 1} packets: {e.Message}");
				throw;
			}
			EndAdjustmentTick ??= EndTick;
			DemoParseResult |= DemoParseResult.Success;
		}


		internal override void WriteToStreamWriter(BitStreamWriter bsw) {
			throw new NotImplementedException();
		}


		internal void LogError(string e) {
			string s = Frames[^1].Packet == null ? "[unknown]" : $"[{Frames[^1].Tick}] {e}";
			ErrorList.Add(s);
			Debug.WriteLine(s);
		}


		public void Parse() {
			_privateReader.CurrentBitIndex = 0;
			Parse(ref _privateReader);
		}


		public override void PrettyWrite(IPrettyWriter pw) {
			pw.AppendLine("Generated by Untitled parser");
			if (FileName != null)
				pw.AppendLine($"file name: {FileName}");
			pw.Append($"predicted game: {DemoInfo.Game}\n\n");

			Header.PrettyWrite(pw);
			foreach (PacketFrame frame in Frames) {
				pw.Append("\n\n");
				frame.PrettyWrite(pw);
			}
			if (_exceptionDuringParsing)
				pw.AppendLine("\n\nAn unhandled exception occured while parsing this demo, the rest could not be parsed...");
			if (ErrorList.Count > 0) {
				pw.AppendLine("\n\nList of errors while parsing: ");
				foreach (string s in ErrorList)
					pw.AppendLine(s);
			} else {
				pw.AppendLine();
			}
		}


		public override string ToString() {
			return $"{FileName}, {Reader.BitLength / 8} bytes long";
		}


		internal BitStreamReader ReaderFromOffset(int offset, int bitLength) {
			return new BitStreamReader(_privateReader.Data, bitLength, offset);
		}


		// todo iterate over ent snapshots
	}


	// flags that get set during parsing, gives a way for other projects to figure out how much data we got, very WIP
	[Flags]
	public enum DemoParseResult {
		Success           = 1,
		EntParsingEnabled = 1 << 1,
		EntParsingFailed  = 1 << 2,
		UnknownGame       = 1 << 3,
		DataTooLong       = 1 << 4,
	}
}
